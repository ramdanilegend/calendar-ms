{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize Express.js with TypeScript project, configure environment variables, and set up the folder structure",
        "details": "1. Create a new Node.js project with `npm init`\n2. Install core dependencies:\n   - Express.js: `npm install express @types/express`\n   - TypeScript: `npm install typescript ts-node @types/node --save-dev`\n   - Environment variables: `npm install dotenv`\n   - Logging: `npm install winston`\n   - JWT: `npm install jsonwebtoken @types/jsonwebtoken`\n3. Initialize TypeScript with `npx tsc --init` and configure `tsconfig.json` with strict type checking\n4. Set up the folder structure as specified in the PRD (Section 5)\n5. Create `.env` file for storing sensitive information (PostgreSQL credentials, Google Calendar API keys)\n6. Configure basic Express.js server in `server.ts`\n7. Set up logging middleware with Winston\n8. Create configuration file in `src/config/config.ts` to load environment variables",
        "testStrategy": "1. Verify the project structure matches the PRD requirements\n2. Ensure TypeScript compilation works without errors\n3. Confirm environment variables are properly loaded\n4. Test basic Express.js server starts and responds to requests\n5. Validate logging functionality works as expected",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Database Schema Implementation",
        "description": "Set up PostgreSQL database with the required tables, constraints, and indexes as specified in the PRD",
        "details": "1. Install PostgreSQL dependencies: `npm install pg @types/pg sequelize @types/sequelize`\n2. Create database connection utility in `src/db/index.ts`\n3. Implement the following tables with TypeScript interfaces:\n   - `events`: Store core event data with unique identifiers and region-specific details\n   - `event_translations`: Store localized titles and descriptions\n   - `calendar_mappings`: Store region-specific date mappings\n   - `update_metadata`: Track last update timestamps\n4. Add constraints and indexes as specified in Section 4 of the PRD:\n   - Unique constraints: `(event_id, region, calendar_type)` for events, `(event_id, language)` for translations\n   - Indexes on `event_id`, `region`, `updated_at`, etc.\n5. Create TypeScript models in `src/db/models/` for each table\n6. Implement database migration scripts for schema creation and updates",
        "testStrategy": "1. Test database connection and configuration\n2. Verify all tables are created with the correct columns, constraints, and indexes\n3. Test CRUD operations on each table to ensure models are correctly implemented\n4. Validate unique constraints prevent duplicate entries\n5. Test performance of indexed queries",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Repository Layer Implementation",
        "description": "Create repository classes for database access with TypeScript interfaces for type safety",
        "details": "1. Create the following repository files in `src/db/repository/`:\n   - `calendarRepository.ts`: For events and calendar data\n   - `translationRepository.ts`: For event translations\n   - `updateRepository.ts`: For update metadata\n2. Implement TypeScript interfaces for each repository method\n3. Create methods for:\n   - Fetching events by ID, region, calendar type\n   - Filtering events by update timestamp\n   - Upserting events and translations\n   - Managing calendar mappings\n   - Tracking update metadata\n4. Implement efficient PostgreSQL queries using prepared statements\n5. Add transaction support for atomic operations\n6. Implement error handling and logging for database operations\n7. Use TypeScript generics for reusable query patterns",
        "testStrategy": "1. Unit test each repository method with mock data\n2. Test transaction rollback on error\n3. Verify query performance with large datasets\n4. Test edge cases (null values, missing records)\n5. Validate type safety with TypeScript compiler",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Base Repository Interface and Common Utilities",
            "description": "Create the foundation for all repositories with shared interfaces, types, and utility functions",
            "dependencies": [],
            "details": "1. Create `src/db/repository/baseRepository.ts` with common interfaces\n2. Define TypeScript interfaces for basic CRUD operations\n3. Implement utility functions for prepared statements\n4. Create error handling wrappers for database operations\n5. Define common types for query parameters and results\n6. Implement pagination utilities\n7. Create logging helpers for database operations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Calendar Repository Implementation",
            "description": "Implement the calendar repository for managing events and calendar data",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Create `src/db/repository/calendarRepository.ts`\n2. Implement interfaces for event data structures\n3. Create methods for fetching events by ID, region, and calendar type\n4. Implement filtering events by update timestamp\n5. Add methods for upserting events\n6. Implement functions for managing calendar mappings\n7. Create efficient PostgreSQL queries with proper indexing\n8. Add unit tests for all repository methods",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Translation Repository Implementation",
            "description": "Implement the translation repository for managing event translations in multiple languages",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Create `src/db/repository/translationRepository.ts`\n2. Define interfaces for translation data structures\n3. Implement methods for fetching translations by event ID and language\n4. Create functions for upserting translations\n5. Add methods for bulk translation operations\n6. Implement language fallback logic\n7. Create efficient queries with proper indexing\n8. Add unit tests for all repository methods",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Update Metadata Repository Implementation",
            "description": "Implement the update repository for tracking and managing update metadata",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Create `src/db/repository/updateRepository.ts`\n2. Define interfaces for update metadata structures\n3. Implement methods for tracking last update timestamps\n4. Create functions for retrieving update history\n5. Add methods for managing update status\n6. Implement efficient queries with proper indexing\n7. Create utilities for update validation\n8. Add unit tests for all repository methods",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Transaction and Error Handling Utilities",
            "description": "Implement transaction support and comprehensive error handling for database operations",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "1. Create `src/db/repository/transactionUtils.ts`\n2. Implement transaction wrapper functions\n3. Create utilities for atomic operations across repositories\n4. Add rollback mechanisms for failed transactions\n5. Implement detailed error classification and handling\n6. Create logging utilities for transaction operations\n7. Add retry logic for transient database errors\n8. Implement unit tests for transaction scenarios",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Google Calendar Integration",
        "description": "Implement Google Calendar API integration for fetching event data annually",
        "details": "1. Install Google Calendar API client: `npm install @googleapis/calendar`\n2. Create `src/google/googleCalendar.ts` for API integration\n3. Implement authentication with Google API using service account credentials\n4. Create TypeScript interfaces for Google Calendar responses\n5. Implement methods to fetch events for Gregorian, Hijri, and Indonesian calendars\n6. Add rate limiting and retry logic to handle API quotas\n7. Create batch processing for efficient API usage\n8. Implement error handling and logging for API calls\n9. Create a scheduler using `node-cron` (`npm install node-cron @types/node-cron`) for annual fetches\n10. Store fetched data in the PostgreSQL database using the repository layer",
        "testStrategy": "1. Mock Google Calendar API responses for testing\n2. Verify authentication works correctly\n3. Test rate limiting and retry logic\n4. Validate event data is correctly parsed and stored\n5. Test scheduler functionality\n6. Verify error handling for API failures",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Authentication and API Client Setup",
            "description": "Set up Google Calendar API client and implement authentication using service account credentials",
            "dependencies": [],
            "details": "1. Install Google Calendar API client: `npm install @googleapis/calendar`\n2. Create `src/google/googleCalendar.ts` file for API integration\n3. Implement service account authentication flow\n4. Create TypeScript interfaces for authentication configuration\n5. Implement error handling for authentication failures\n6. Add unit tests with mocked authentication responses\n7. Create a configuration file for API credentials and settings",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Calendar Data Fetching Implementation",
            "description": "Implement methods to fetch events from different calendar types (Gregorian, Hijri, and Indonesian)",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create TypeScript interfaces for Google Calendar API responses\n2. Implement methods to fetch Gregorian calendar events\n3. Implement methods to fetch Hijri calendar events\n4. Implement methods to fetch Indonesian calendar events\n5. Add error handling for API response parsing\n6. Create utility functions for date formatting and validation\n7. Implement logging for successful and failed API calls",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Rate Limiting and Batch Processing",
            "description": "Implement rate limiting, retry logic, and batch processing for efficient API usage",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create a rate limiter utility to respect Google API quotas\n2. Implement exponential backoff retry logic for failed API calls\n3. Create batch processing functionality to optimize API usage\n4. Add configurable parameters for rate limits and retry attempts\n5. Implement circuit breaker pattern to prevent cascading failures\n6. Add detailed logging for rate limiting and retry events\n7. Create unit tests for rate limiting and retry logic",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Data Transformation and Storage",
            "description": "Transform Google Calendar data and store it in the PostgreSQL database",
            "dependencies": [
              "4.2",
              "4.3"
            ],
            "details": "1. Create data transformation functions to convert API responses to database models\n2. Implement repository methods to store calendar events in the database\n3. Add validation for transformed data before storage\n4. Implement deduplication logic to prevent duplicate events\n5. Create error handling for database operations\n6. Add transaction support for batch inserts\n7. Implement logging for data transformation and storage operations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Scheduler Implementation for Annual Fetches",
            "description": "Create a scheduler using node-cron for annual fetches of calendar data",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "1. Install node-cron: `npm install node-cron @types/node-cron`\n2. Create a scheduler service in `src/services/scheduler.ts`\n3. Implement cron job configuration for annual calendar data fetches\n4. Add configurable schedule parameters\n5. Implement error handling and recovery for failed scheduled jobs\n6. Create logging for scheduler events (start, completion, failure)\n7. Add unit tests for scheduler functionality with mocked time",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Calendar Conversion Service",
        "description": "Implement calendar conversion logic for Gregorian, Hijri, and Indonesian calendars",
        "details": "1. Install Hijri conversion library: `npm install hijri-js`\n2. Create `src/services/converter.ts` for calendar conversion logic\n3. Implement TypeScript interfaces for date formats and conversion results\n4. Create methods for:\n   - Converting Gregorian to Hijri dates\n   - Handling Indonesia's rukyat-based Hijri calendar\n   - Applying regional calendar mappings\n5. Implement fallback logic when mappings are unavailable\n6. Add validation for date formats and ranges\n7. Create utility functions for date manipulation\n8. Implement logging for conversion operations and fallbacks\n9. Ensure thread-safety for concurrent conversions",
        "testStrategy": "1. Unit test conversion accuracy for known date pairs\n2. Test fallback logic when mappings are missing\n3. Verify Indonesia's rukyat-based dates are correctly handled\n4. Test edge cases (leap years, date boundaries)\n5. Validate type safety with TypeScript compiler",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Core Gregorian to Hijri Conversion Implementation",
            "description": "Implement the core conversion utilities for transforming Gregorian dates to Hijri dates using the hijri-js library",
            "dependencies": [],
            "details": "1. Install hijri-js library with `npm install hijri-js`\n2. Create base TypeScript interfaces in `src/services/converter.ts` for date formats and conversion results\n3. Implement the core conversion method for Gregorian to standard Hijri dates\n4. Add proper error handling for invalid date inputs\n5. Create unit tests for conversion accuracy with known date pairs\n6. Implement logging for conversion operations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Indonesia's Rukyat-based Calendar Implementation",
            "description": "Implement specialized handling for Indonesia's rukyat-based Hijri calendar which differs from standard Hijri calculations",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Research and document Indonesia's rukyat-based calendar rules\n2. Extend the converter service to handle Indonesia-specific date adjustments\n3. Implement logic to determine when rukyat observations override calculated dates\n4. Create a configuration system for regional variations within Indonesia\n5. Develop test cases specifically for Indonesian calendar edge cases\n6. Implement logging for Indonesia-specific conversions",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Regional Mapping and Fallback Logic",
            "description": "Implement the system for applying regional calendar mappings and fallback logic when official mappings are unavailable",
            "dependencies": [
              "5.1",
              "5.2"
            ],
            "details": "1. Create interfaces for regional calendar mappings\n2. Implement methods to retrieve and apply region-specific date adjustments\n3. Develop fallback logic for when mappings are unavailable\n4. Create a priority system for multiple mapping sources\n5. Implement caching for frequently accessed mappings\n6. Add comprehensive tests for mapping application and fallback scenarios\n7. Ensure thread-safety for concurrent conversion operations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Validation and Utility Functions",
            "description": "Implement validation logic for date formats and ranges, plus utility functions for date manipulation across calendar systems",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Create comprehensive date validation functions for all supported calendar systems\n2. Implement utility functions for date manipulation (add/subtract days, months, years)\n3. Add range validation to prevent out-of-range date conversions\n4. Create formatting utilities for different regional date display preferences\n5. Implement comparison functions that work across different calendar systems\n6. Develop test cases for all validation and utility functions\n7. Document usage examples for the utility functions",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Authentication and Authorization Middleware",
        "description": "Implement JWT-based authentication and authorization for admin-only endpoints",
        "details": "1. Create `src/api/middleware/auth.ts` for JWT validation\n2. Implement TypeScript interfaces for JWT payload and user roles\n3. Create middleware to validate JWT tokens for admin routes\n4. Implement role-based access control (RBAC) for admin vs. general users\n5. Add error handling for invalid or expired tokens\n6. Create utility functions for token generation (for testing)\n7. Implement logging for authentication attempts and failures\n8. Configure WindSURF integration for additional security (if applicable)\n9. Add rate limiting middleware for public endpoints\n10. Implement HTTPS enforcement via Express.js or WindSURF",
        "testStrategy": "1. Test token validation with valid and invalid JWTs\n2. Verify admin-only routes reject non-admin users\n3. Test rate limiting functionality\n4. Validate error responses for authentication failures\n5. Test integration with WindSURF (if applicable)",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "JWT Validation and Payload Processing",
            "description": "Implement JWT token validation middleware and TypeScript interfaces for payload handling",
            "dependencies": [],
            "details": "1. Create `src/api/middleware/auth.ts` for JWT validation\n2. Implement TypeScript interfaces for JWT payload structure\n3. Define user role enums and interfaces\n4. Create utility functions for token verification\n5. Implement secure token extraction from request headers\n6. Add utility functions for token generation (for testing purposes)\n7. Ensure proper secret key management using environment variables",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Role-Based Access Control Implementation",
            "description": "Develop middleware for role-based authorization and admin route protection",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Create middleware to validate admin permissions\n2. Implement role checking functions based on JWT claims\n3. Add route protection helpers for admin-only endpoints\n4. Create middleware composition for different authorization levels\n5. Implement user context extraction for downstream handlers\n6. Add logging for authorization decisions\n7. Ensure proper error handling for insufficient permissions",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Authentication Error Handling and Security Responses",
            "description": "Implement comprehensive error handling for authentication failures and security events",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "1. Create standardized error responses for authentication failures\n2. Implement handling for expired tokens\n3. Add security for malformed token attempts\n4. Create logging middleware for authentication attempts and failures\n5. Implement secure headers in responses\n6. Add timing attack protection\n7. Configure proper HTTP status codes for different authentication scenarios\n8. Ensure no sensitive information is leaked in error responses",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Rate Limiting and Additional Security Features",
            "description": "Implement rate limiting middleware and additional security enhancements",
            "dependencies": [
              "6.3"
            ],
            "details": "1. Add rate limiting middleware for public endpoints\n2. Configure different rate limits for authenticated vs unauthenticated requests\n3. Implement HTTPS enforcement via Express.js\n4. Configure WindSURF integration for additional security (if applicable)\n5. Add IP-based blocking for repeated authentication failures\n6. Implement request validation to prevent injection attacks\n7. Add security headers (Content-Security-Policy, X-XSS-Protection, etc.)\n8. Create documentation for security features and configuration options",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "API Endpoints Implementation",
        "description": "Implement the core API endpoints as specified in the PRD",
        "details": "1. Create route files in `src/api/routes/`\n2. Implement handlers in `src/api/handlers/` for:\n   - `GET /updates/check`: Check last update timestamp\n   - `GET /events` and `GET /events/:event_id`: Fetch events with filtering\n   - `POST /events/sync`: Manual fetch of event data (admin-only)\n   - `POST /calendar/mappings`: Update calendar mappings (admin-only)\n3. Create TypeScript interfaces for request and response payloads\n4. Implement validation middleware in `src/api/middleware/validation.ts`\n5. Add error handling for invalid requests\n6. Implement query parameter parsing and validation\n7. Create response formatting utilities\n8. Add logging for API requests and responses\n9. Implement business rules from Section 7 of the PRD\n10. Integrate with repository layer for data access",
        "testStrategy": "1. Unit test each endpoint with mock repositories\n2. Test validation logic with valid and invalid requests\n3. Verify response formats match PRD specifications\n4. Test filtering logic (region, language, updated_after)\n5. Validate admin-only endpoints require authentication\n6. Test error handling for edge cases",
        "priority": "high",
        "dependencies": [
          3,
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Route Setup and Middleware Configuration",
            "description": "Create the API route structure and configure necessary middleware for the application",
            "dependencies": [],
            "details": "1. Create main router file in `src/api/routes/index.ts`\n2. Set up route files for each endpoint category: `src/api/routes/updates.ts`, `src/api/routes/events.ts`, and `src/api/routes/calendar.ts`\n3. Configure Express middleware for request parsing, CORS, and security\n4. Implement authentication middleware for admin-only routes\n5. Set up route registration in the main application file\n6. Create base controller class with common response methods",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Update Check Endpoint Implementation",
            "description": "Implement the GET /updates/check endpoint for checking last update timestamp",
            "dependencies": [
              "7.1"
            ],
            "details": "1. Create handler in `src/api/handlers/updates.ts`\n2. Define TypeScript interface for update check response in `src/api/types/responses.ts`\n3. Integrate with updateRepository to fetch last update timestamp\n4. Implement caching strategy for frequent requests\n5. Add response formatting with proper HTTP status codes\n6. Document API specifications including query parameters and response format\n7. Implement unit tests for the endpoint",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Event Retrieval Endpoints Implementation",
            "description": "Implement GET /events and GET /events/:event_id endpoints with filtering capabilities",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "1. Create handlers in `src/api/handlers/events.ts`\n2. Define TypeScript interfaces for event list and single event responses\n3. Implement filtering logic for region, language, and updated_after parameters\n4. Integrate with calendarRepository for data retrieval\n5. Implement pagination for event list endpoint\n6. Add calendar conversion using the Calendar Conversion Service\n7. Handle not found cases for event_id endpoint\n8. Implement unit tests with various filter combinations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Admin-only Endpoints Implementation",
            "description": "Implement POST /events/sync and POST /calendar/mappings admin-only endpoints",
            "dependencies": [
              "7.1"
            ],
            "details": "1. Create handlers in `src/api/handlers/admin.ts`\n2. Define TypeScript interfaces for admin request and response payloads\n3. Implement authentication checks using admin middleware\n4. Integrate with Google Calendar service for event synchronization\n5. Implement calendar mapping updates with validation\n6. Add transaction support for database operations\n7. Implement proper error handling and rollback mechanisms\n8. Create unit tests with mock authentication",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Request Validation and Error Handling",
            "description": "Implement comprehensive request validation and error handling for all API endpoints",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "1. Create validation middleware in `src/api/middleware/validation.ts`\n2. Define validation schemas for each endpoint using a validation library\n3. Implement query parameter parsing and validation\n4. Create custom error classes in `src/api/errors/`\n5. Implement global error handler middleware\n6. Add validation for date formats, regions, and languages\n7. Create standardized error response format\n8. Implement unit tests for validation with invalid requests",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Response Formatting and Logging",
            "description": "Implement response formatting utilities and comprehensive API request/response logging",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4",
              "7.5"
            ],
            "details": "1. Create response formatting utilities in `src/api/utils/responseFormatter.ts`\n2. Implement logging middleware for API requests and responses\n3. Add request ID generation for request tracing\n4. Create structured logging format with appropriate log levels\n5. Implement performance metrics logging\n6. Add sanitization for sensitive data in logs\n7. Create utility for consistent HTTP status code usage\n8. Implement unit tests for response formatting",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Localization and Translation Service",
        "description": "Implement localization logic for event titles and descriptions in multiple languages",
        "details": "1. Create `src/services/translation.ts` for localization logic\n2. Implement TypeScript interfaces for translations and language codes\n3. Create methods for:\n   - Fetching translations by event ID and language\n   - Handling fallbacks when translations are unavailable\n   - Managing translation updates\n4. Implement caching for frequently accessed translations\n5. Add validation for language codes (id, en, ar)\n6. Create utility functions for text formatting\n7. Implement logging for translation operations\n8. Ensure thread-safety for concurrent access",
        "testStrategy": "1. Unit test translation fetching with mock data\n2. Test fallback logic when translations are missing\n3. Verify caching improves performance\n4. Test with various language codes\n5. Validate type safety with TypeScript compiler",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Scheduled Tasks and Scripts",
        "description": "Implement scripts for annual Google Calendar fetch and calendar mapping updates",
        "details": "1. Create `scripts/fetchCalendar.ts` for annual Google Calendar fetch\n2. Implement `scripts/updateMappings.ts` for Kementerian Agama mapping updates\n3. Use `node-cron` for scheduling annual fetches\n4. Create TypeScript interfaces for script configurations and results\n5. Implement logging for script execution and results\n6. Add error handling and retry logic\n7. Create database transaction support for atomic updates\n8. Implement notification mechanism for failed jobs\n9. Add command-line arguments for manual execution\n10. Create documentation for script usage",
        "testStrategy": "1. Test scripts with mock data\n2. Verify scheduling works correctly\n3. Test error handling and retry logic\n4. Validate database updates are atomic\n5. Test manual execution with various arguments",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Testing, Documentation, and Deployment",
        "description": "Implement comprehensive testing, documentation, and deployment configuration",
        "details": "1. Set up testing framework: `npm install jest ts-jest @types/jest supertest @types/supertest --save-dev`\n2. Create unit tests for all components\n3. Implement integration tests for API endpoints\n4. Create performance tests for database queries\n5. Add documentation in README.md:\n   - API endpoint specifications\n   - Database schema\n   - TypeScript interfaces\n   - Environment variables\n   - Deployment instructions\n6. Create OpenAPI/Swagger documentation for API endpoints\n7. Implement logging and monitoring configuration\n8. Create deployment scripts and configuration\n9. Set up CI/CD pipeline for automated testing and deployment\n10. Implement database backup and recovery procedures",
        "testStrategy": "1. Verify all tests pass with good coverage\n2. Test documentation accuracy and completeness\n3. Validate deployment in test environment\n4. Test monitoring and logging functionality\n5. Verify backup and recovery procedures",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-16T07:32:05.636Z",
      "updated": "2025-08-18T07:24:37.481Z",
      "description": "Tasks for master context"
    }
  }
}